package main

import (
	"github.com/bytbox/go-pop3"
	"github.com/inexio/go-monitoringplugin"
	"github.com/jessevdk/go-flags"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"os"
	"regexp"
	"strings"
	"time"
)

const refreshDuration = "45m0s"

var opts struct {
	Hostname string `short:"h" long:"hostname" description:"The hostname of the pop3 server" required:"true"`
	Username string `short:"u" long:"username" description:"The username of the pop3 account" required:"true"`
	Password string `short:"p" long:"password" description:"The password of the pop3 account" required:"true"`
	Port     string `short:"P" long:"port" description:"The port of the pop3 server, default is 110. Optional" required:"false"`
	Secure   []bool `short:"s" long:"secure" description:"Use secure TLS/SSL connection to the pop3 server. Optional" required:"false"`
}

func newPop3Client(host, user, password string, secure bool) (*pop3.Client, error) {
	var client *pop3.Client
	var err error
	if secure {
		client, err = pop3.DialTLS(host)
		if err != nil {
			err := errors.Wrap(err, "Failed to connect to POP3 Server")
			return nil, err
		}
	} else {
		client, err = pop3.Dial(host)
		if err != nil {
			err := errors.Wrap(err, "Failed to connect to POP3 Server")
			return nil, err
		}
	}

	if err = client.User(user); err != nil {
		err := errors.Wrap(err, "Error during POP3-User Command")
		return nil, err
	}

	if err = client.Pass(password); err != nil {
		err := errors.Wrap(err, "Error during POP3-Pass Command")
		return nil, err
	}

	return client, nil
}

func closePop3Client(client *pop3.Client) error {
	err := client.Quit()
	if err != nil {
		log.Error().
			AnErr("Error", err).
			Msg("Error while quitting POP3 Client")
		return err
	}

	return nil
}

func main() {
	_, err := flags.ParseArgs(&opts, os.Args)
	if err != nil {
		os.Exit(3) //parseArgs() prints errors to stdout
	}

	response := monitoringplugin.NewResponse("checked")
	defer response.OutputAndExit()

	var hostname string
	if opts.Port == "" {
		hostname = opts.Hostname + ":110"
	} else {
		hostname = opts.Hostname + ":" + opts.Port
	}
	var secure bool
	if opts.Secure == nil {
		secure = false
	} else {
		secure = true
	}
	client, err := newPop3Client(hostname, opts.Username, opts.Password, secure)
	if err != nil {
		response.UpdateStatus(monitoringplugin.UNKNOWN, "Could not connect to POP3 Client: "+err.Error())
		return
	}
	defer func() {
		err = closePop3Client(client)
		if err != nil {
			response.UpdateStatus(monitoringplugin.UNKNOWN, "Could not disconnect POP3 Client: "+err.Error())
			return
		}
	}()

	messageInfo, _, err := client.ListAll()
	if err != nil {
		response.UpdateStatus(monitoringplugin.UNKNOWN, "Could not get message info: "+err.Error())
		return
	}

	regex := regexp.MustCompile("..., .. ... .... ..:..:.. .....")
	duration, _ := time.ParseDuration(refreshDuration)

	for _, mi := range messageInfo {
		content, err := client.Retr(mi)
		if err != nil {
			response.UpdateStatus(monitoringplugin.UNKNOWN, "Error during POP3-Retr Command: "+err.Error())
			return
		}

		dateReceived := regex.FindString(content)
		words := strings.Fields(dateReceived)
		if len(words[1]) == 1 {
			words[1] = "0" + words[1]
		}
		dateReceived = strings.Join(words[:], " ")
		t, _ := time.Parse(time.RFC1123Z, dateReceived)
		if time.Now().UTC().Sub(t) > duration {
			response.UpdateStatus(monitoringplugin.CRITICAL, "The POP3-Client contains E-Mails older than 45min!")
			return
		}
	}
}
